% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/calibrate.R
\name{calibrate}
\alias{calibrate}
\alias{calibrate,EffectScenario-method}
\alias{calibrate,list-method}
\title{Fit model parameters to experimental data}
\usage{
calibrate(x, ...)

\S4method{calibrate}{EffectScenario}(
  x,
  par,
  data,
  endpoint,
  hessian = TRUE,
  metric.fun = sse,
  as.tibble = FALSE,
  catch.errors = TRUE,
  verbose = FALSE,
  ...
)

\S4method{calibrate}{list}(
  x,
  par,
  endpoint,
  hessian = TRUE,
  metric.fun = sse,
  metric.total = sum,
  as.tibble = FALSE,
  catch.errors = TRUE,
  verbose = FALSE,
  ...
)
}
\arguments{
\item{x}{either a single \code{EffectScenario} or a list of \code{CalibrationSet} objects to be fitted}

\item{...}{additional parameters passed on to \code{stats::optim()} and \code{simulate()}}

\item{par}{named numeric vector with parameters to fit and their start values}

\item{data}{\code{data.frame} with two or more columns with experimental data,
1st column contains time points, 2nd and following columns contain values
which the scenario is fitted to.}

\item{endpoint}{\code{character}, name of model output column to optimize on}

\item{hessian}{\code{logical}, if \code{TRUE} the Hessian is returned by the optimization routine}

\item{metric.fun}{vectorized function to calculate an error term that is
minimized during optimization, defaults to sum of squared errors}

\item{as.tibble}{\code{logical}, if \code{TRUE} a tibble with scenario and optimization
result is returned, else only the optimization result is returned}

\item{catch.errors}{\code{logical}, if \code{TRUE} simulation errors due to e.g. out of
bounds parameters are caught and optimization continues, else optimization fails}

\item{verbose}{\code{logical}, if \code{TRUE} then debug outputs are displayed during
optimization}

\item{metric.total}{vectorized function to aggregate multiple error terms to a
single value, defaults to \code{sum()}}
}
\value{
By default, a list of fitted parameters (as produced by \code{\link[stats:optim]{stats::optim()}})
is returned. Alternatively, when setting the argument as.tibble = TRUE,
a \code{tibble} is returned with 2 columns, the first column lists the
scenario and the 2nd column the list of fitted parameters.
}
\description{
The function \code{calibrate()}performs the calibration (fitting) of model parameters to observed data.
Two options are available: One can either calibrate a single \linkS4class{EffectScenario} (with corresponding observations on effect data),
or one can fit to a list of one or more \linkS4class{CalibrationSet} objects (i.e., a combiation of \code{EffectScenario}
and effect data joined together into a \code{CalibrationSet} object). The latter allows one to combine the results from several experiments
within one fitting process.

Effect data should be supplied in long format with 2 columns: the timepoints and the observations. Effect data can contain replicates as extra rows.
}
\examples{
# Example with Lemna ----------------------------------------------
# 1st option: with an EffectScenario ----------------------------
# EffectScenario
is(metsulfuron)
# Effect data
obs32 <- Schmitt2013 \%>\%
  dplyr::filter(ID == "T0.32") \%>\%
  dplyr::select(t, obs) # can only contain t and conc
# calibrate with an ExposureScenario and corresponding effect data
calib_scen <- calibrate(
  x = metsulfuron,
  par = c(k_phot_max = 1, k_resp = 0.1 ),
  data = obs32,
  endpoint = "BM",
 )
# check return
is(calib_scen)
calib_scen
# plot
obs32$trial <- "trail1"
colnames(obs32) <- c("time", "obs", "trial")
plot_sd(model_base = metsulfuron,
  treatments = metsulfuron@exposure@series,
  rs_mean = obs32)

# 2nd option: with list of CalibrationSets ----------------------
# step 1. list of EffectScenarios
list_of_eff_scen <- Schmitt2013 \%>\%
  dplyr::group_by(ID) \%>\%
  dplyr::group_map(~ metsulfuron \%>\% set_exposure(data.frame(.x$t, .x$conc)))
# step 2. list of effect data
list_of_eff_data <- Schmitt2013 \%>\%
  dplyr::group_by(ID) \%>\%
  dplyr::group_map(~data.frame(.x$t, .x$obs))
# step 3. combined into list of CalibrationSets
list_of_calib_sets <- list()
for(i in 1:length(list_of_eff_scen)){
  list_of_calib_sets[[i]] <- CalibrationSet(list_of_eff_scen[[i]], list_of_eff_data[[i]])
}
# 4. calibrate
calib_scen_list <- calibrate(
 x = list_of_calib_sets, # list of calibration sets
 par = c(k_phot_max = 1),
 endpoint = "BM",
)
 # check return
is(calib_scen_list)
calib_scen_list$scenario[[1]]


}
